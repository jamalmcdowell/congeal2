<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Congeal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f1115;
      --panel: #161a21;
      --accent: #6ee7b7;
      --muted: #a0a8b8;
      --text: #e7e9ee;

      /* Wordle-style coloring */
      --correct: #22c55e;   /* green */
      --present: #eab308;   /* yellow */
      --absent: #ffffff;    /* white */

      --locked-border: #22c55e;
      --tile-bg: #0e1320;
      --tile-border: #273043;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: radial-gradient(1200px 600px at 70% -10%, #1b2230, var(--bg));
      color: var(--text); display: grid; place-items: center; padding: 20px;
    }

    .wrap { width: 100%; max-width: 920px; }
    header {
      display: flex; align-items: center; justify-content: space-between;
      margin-bottom: 16px; gap: 10px;
    }
    h1 { font-size: 22px; margin: 0; letter-spacing: 0.5px; }
    .meta { color: var(--muted); font-size: 14px; }

    .panel {
      background: linear-gradient(180deg, #171b23, #12161d);
      border: 1px solid #222938; border-radius: 14px; padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      width: 100%;
    }

    .topbar { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
    .linkbar { display: flex; gap: 8px; align-items: center; flex: 1; min-width: 340px; }
    .linkbar input {
      flex: 1; min-width: 260px; padding: 10px 12px; border-radius: 10px; border: 1px solid #273043;
      background: #0e1320; color: #cfe3ff; font-size: 14px;
    }
    button {
      background: var(--accent); color: #0a0f0d; font-weight: 700; border: 0;
      padding: 10px 14px; border-radius: 12px; cursor: pointer;
    }

    .namebar { display: flex; gap: 8px; align-items: center; margin: 6px 0 12px; flex-wrap: wrap; }
    .namebar input {
      min-width: 160px; padding: 8px 10px; border-radius: 10px; border: 1px solid #273043;
      background: #0e1320; color: #cfe3ff; font-size: 14px;
    }

    .colorbar { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-bottom: 12px; }
    .colorbar label { color: var(--muted); font-size: 14px; }
    .colorSelect {
      padding: 8px 10px; border-radius: 10px; border: 1px solid #273043;
      background: #0e1320; color: #cfe3ff; font-size: 14px; min-width: 180px;
    }
    .dot {
      width: 14px; height: 14px; border-radius: 50%; border: 1px solid #1f2937;
      display: inline-block; vertical-align: middle; margin-left: 6px;
    }

    /* grid */
    #grid { display: grid; gap: 10px; justify-content: center; }
    .row { display: grid; grid-template-columns: repeat(5, 64px); gap: 10px; }
    .tile {
      width: 64px; height: 64px; border-radius: 10px;
      border: 2px solid var(--tile-border); background: var(--tile-bg);
      display: grid; place-items: center; font-weight: 800; font-size: 28px;
      text-transform: uppercase; letter-spacing: 1px; user-select: none;
      outline: none; color: var(--text);
      transition: transform .08s ease, border-color .15s ease, background .15s ease;
    }
    .tile.focus { box-shadow: 0 0 0 3px rgba(110,231,183,.35); }
    .tile.locked { border-color: var(--locked-border) !important; } /* keep green when submitted */

    /* assist bar under current row */
    #assist { display: grid; grid-template-columns: repeat(5, 64px); gap: 10px; justify-content: center; margin: 6px 0 8px; }
    #assist .fillBtn {
      padding: 6px 10px; border-radius: 8px; border: 1px solid #273043;
      background: #0f1626; color: #cfe3ff; font-size: 12px; cursor: pointer;
    }
    #assist .fillBtn[disabled] { opacity: .45; cursor: not-allowed; }

    /* reveal colors */
    .tile.correct { background: var(--correct); border-color: #16a34a !important; color: #081207; }
    .tile.present { background: var(--present); border-color: #9e7d05 !important; color: #0a0900; }
    .tile.absent  { background: var(--absent);  border-color: #cbd5e1 !important; color: #0b0f17; }

    .roster { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; margin-top: 8px; }
    .slotBadge {
      padding: 6px 8px; border-radius: 10px; background: #0e1420; border: 1px solid #222938;
      text-align: center; font-size: 12px; color: var(--muted); display: flex; justify-content: center; align-items: center; gap: 6px;
    }

    .toast { margin-top: 10px; color: #ffd19a; min-height: 20px; }
    .gameOver {
      text-align: center; padding: 12px; border-radius: 12px;
      background: #161d29; border: 1px solid #273043; margin-top: 12px;
      cursor: pointer;
    }

    /* modal */
    .modal {
      position: fixed; inset: 0; display: none;
      align-items: center; justify-content: center;
      background: rgba(6, 9, 14, .6);
      z-index: 999;
      backdrop-filter: blur(2px);
    }
    .modal.open { display: flex; }
    .modal .box {
      background: linear-gradient(180deg, #171b23, #12161d);
      border: 1px solid #222938; border-radius: 14px; padding: 18px;
      width: min(640px, 92vw); color: var(--text);
      box-shadow: 0 20px 60px rgba(0,0,0,.35);
    }
    .modal header {
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
      margin: 0 0 10px 0;
    }
    .modal h2 { font-size: 18px; margin: 0; }
    .xbtn {
      background: transparent; color: #cfe3ff; border: 1px solid #273043;
      padding: 6px 10px; border-radius: 10px; cursor: pointer;
    }
    .modal ul { margin: 0; padding-left: 18px; }
    .kbd {
      border: 1px solid #334155; background: #0b1220; padding: 2px 6px; border-radius: 6px; font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Congeal</h1>
      <div class="meta" id="status">connecting‚Ä¶</div>
    </header>

    <div class="panel">
      <div class="topbar">
        <div class="linkbar">
          <input id="share" readonly />
          <button id="copy">Copy Link</button>
        </div>
        <button id="newRoom">Refresh Room Code</button>
        <button id="howToBtn">How to play</button>
      </div>

      <div class="namebar">
        <input id="nameInput" maxlength="16" placeholder="Your name" />
        <button id="saveName">Save</button>
      </div>

      <div class="colorbar">
        <label for="colorSelect">Border color:</label>
        <select id="colorSelect" class="colorSelect"></select>
        <span id="colorPreview" class="dot"></span>
      </div>

      <div id="grid"></div>
      <!-- Assist bar: fill unoccupied slots with the correct letter (current row only) -->
      <div id="assist"></div>

      <div class="roster" id="roster"></div>
      <div class="toast" id="toast"></div>
      <div class="gameOver" id="gameOver" hidden></div>
    </div>
  </div>

  <!-- How to play modal -->
  <div id="howtoModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="howtoTitle">
    <div class="box" role="document">
      <header>
        <h2 id="howtoTitle">How to play</h2>
        <button id="howtoClose" class="xbtn" aria-label="Close">‚úñ</button>
      </header>
      <div>
        <ul>
          <li>This is a 5-player co-op Wordle. Each player controls <strong>one letter slot</strong> per row.</li>
          <li>Type a letter; everyone sees it live. Press <span class="kbd">Enter</span> to <strong>lock</strong> your slot (green border).</li>
          <li>If a slot is <strong>unoccupied</strong>, use the <em>Fill</em> button under it to auto-lock the correct letter.</li>
          <li>When all 5 slots are locked, the row is scored and revealed:
            <ul>
              <li><strong>Green</strong> = correct letter & position</li>
              <li><strong>Yellow</strong> = letter is in the word (wrong spot)</li>
              <li><strong>White</strong> = letter not in the word</li>
            </ul>
          </li>
          <li>You have <strong>5 guesses</strong> to find the word.</li>
          <li>Share the lobby link so friends can join. Use ‚ÄúRefresh Room Code‚Äù to start a fresh lobby.</li>
          <li>Set your name and pick a <strong>border color</strong> ‚Äî visible to everyone while typing.</li>
          <li>Even if a word isn‚Äôt in the list, the guess still counts and reveals colors.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    // Elements
    const qs = (s) => document.querySelector(s);
    const gridEl = qs("#grid");
    const assistEl = qs("#assist");
    const rosterEl = qs("#roster");
    const shareEl = qs("#share");
    const copyBtn = qs("#copy");
    const newRoomBtn = qs("#newRoom");
    const statusEl = qs("#status");
    const toastEl = qs("#toast");
    const gameOverEl = qs("#gameOver");
    const nameInput = qs("#nameInput");
    const saveNameBtn = qs("#saveName");
    const colorSelect = qs("#colorSelect");
    const colorPreview = qs("#colorPreview");

    // Modal elements
    const howToBtn = qs("#howToBtn");
    const howtoModal = qs("#howtoModal");
    const howtoClose = qs("#howtoClose");
    let _modalPrevFocus = null;

    const params = new URLSearchParams(location.search);

    // Ensure we have a lobby code; else create one.
    async function ensureLobby() {
      if (!params.get("lobby")) {
        const res = await fetch("/create");
        const data = await res.json();
        const url = new URL(location.href);
        url.searchParams.set("lobby", data.lobbyId);
        history.replaceState({}, "", url.toString());
      }
    }

    // State
    let ws, mySlot = null;
    let round = 0, maxRounds = 5; // default 5; server will confirm
    const rows = []; // [{ el, tiles[5] }]
    const rosterColors = Array(5).fill(null);
    const rosterOccupied = Array(5).fill(false);

    // Name bootstrap
    let displayName =
      (params.get("name") || localStorage.getItem("name") || "Player").trim().slice(0,16);
    localStorage.setItem("name", displayName);

    // Color palette (must match server)
    const PALETTE = ["#60A5FA","#F472B6","#F59E0B","#A78BFA","#14B8A6","#EF4444","#22D3EE","#FB7185","#8B5CF6","#F97316"];
    let myColor = localStorage.getItem("borderColor") || PALETTE[0];

    // Helpers
    function setStatus(msg) { statusEl.textContent = msg; }
    function showToast(msg) {
      toastEl.textContent = msg || "";
      if (!msg) return;
      setTimeout(() => { if (toastEl.textContent === msg) toastEl.textContent = ""; }, 2500);
    }
    function setShareLink() {
      shareEl.value = location.href;
      copyBtn.onclick = async () => {
        await navigator.clipboard.writeText(shareEl.value);
        showToast("Link copied.");
      };
      newRoomBtn.onclick = async () => {
        const res = await fetch("/create");
        const data = await res.json();
        location.href = data.joinUrl;
      };
    }

    function labelForColor(hex) {
      const map = {
        "#60A5FA": "Blue",
        "#F472B6": "Pink",
        "#F59E0B": "Amber",
        "#A78BFA": "Violet",
        "#14B8A6": "Teal",
        "#EF4444": "Red",
        "#22D3EE": "Cyan",
        "#FB7185": "Rose",
        "#8B5CF6": "Indigo",
        "#F97316": "Orange"
      };
      return map[hex] || hex;
    }

    function buildColorDropdown() {
      colorSelect.innerHTML = "";
      for (const col of PALETTE) {
        const opt = document.createElement("option");
        opt.value = col;
        opt.textContent = labelForColor(col);
        colorSelect.appendChild(opt);
      }
      if (!PALETTE.includes(myColor)) myColor = PALETTE[0];
      colorSelect.value = myColor;
      colorPreview.style.background = myColor;

      colorSelect.onchange = () => {
        myColor = colorSelect.value;
        localStorage.setItem("borderColor", myColor);
        colorPreview.style.background = myColor;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "setColor", color: myColor }));
        }
        applyCustomBorders();
      };
    }

    // Modal wiring
    function openHowto() {
      _modalPrevFocus = document.activeElement;
      howtoModal.classList.add("open");
      howtoModal.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";
      howtoClose.focus();
    }
    function closeHowto() {
      howtoModal.classList.remove("open");
      howtoModal.setAttribute("aria-hidden", "true");
      document.body.style.overflow = "";
      if (_modalPrevFocus) _modalPrevFocus.focus();
    }
    howToBtn.addEventListener("click", openHowto);
    howtoClose.addEventListener("click", closeHowto);
    howtoModal.addEventListener("click", (e) => { if (e.target === howtoModal) closeHowto(); });
    document.addEventListener("keydown", (e) => { if (e.key === "Escape" && howtoModal.classList.contains("open")) closeHowto(); });

    // Grid
    function buildGrid() {
      gridEl.innerHTML = "";
      gridEl.style.gridTemplateRows = `repeat(${maxRounds}, 64px)`;
      rows.length = 0;
      for (let r = 0; r < maxRounds; r++) {
        const row = document.createElement("div");
        row.className = "row";
        const tiles = [];
        for (let c = 0; c < 5; c++) {
          const t = document.createElement("div");
          t.className = "tile";
          t.tabIndex = -1;
          t.textContent = "";
          row.appendChild(t);
          tiles.push(t);
        }
        gridEl.appendChild(row);
        rows.push({ el: row, tiles });
      }
      buildAssistBar();
    }
    function currentRowTiles() { return rows[round]?.tiles || []; }

    function focusMyTile() {
      if (mySlot == null) return;
      const tile = currentRowTiles()[mySlot];
      if (tile) { tile.classList.add("focus"); tile.focus({ preventScroll: true }); }
    }
    function blurMyTile() {
      const tile = currentRowTiles()[mySlot];
      if (tile) tile.classList.remove("focus");
    }

    // Assist bar under current row
    function buildAssistBar() {
      assistEl.innerHTML = "";
      for (let i = 0; i < 5; i++) {
        const btn = document.createElement("button");
        btn.className = "fillBtn";
        btn.textContent = "Fill";
        btn.title = "Auto-lock the correct letter for this slot";
        btn.onclick = () => {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "fillSlot", slot: i }));
          }
        };
        assistEl.appendChild(btn);
      }
      renderAssist(); // apply initial disabled states
    }
    function renderAssist() {
      const buttons = assistEl.querySelectorAll(".fillBtn");
      const tiles = currentRowTiles();
      for (let i = 0; i < 5; i++) {
        const btn = buttons[i];
        const t = tiles[i];
        const locked = t?.classList.contains("locked");
        const revealed = t?.classList.contains("correct") || t?.classList.contains("present") || t?.classList.contains("absent");
        // Disable if slot occupied by player, or already locked/revealed
        btn.disabled = !!rosterOccupied[i] || locked || revealed;
      }
    }

    // Apply per-slot custom borders to the current row (only when not locked/revealed)
    function applyCustomBorders() {
      const tiles = currentRowTiles();
      for (let i = 0; i < 5; i++) {
        const t = tiles[i];
        if (!t) continue;
        const isLocked = t.classList.contains("locked");
        const isRevealed = t.classList.contains("correct") || t.classList.contains("present") || t.classList.contains("absent");
        if (!isLocked && !isRevealed) {
          const col = rosterColors[i] || "#273043";
          t.style.borderColor = col;
        } else {
          t.style.borderColor = ""; // let locked/reveal CSS win
        }
      }
    }

    // Typing directly into your tile (with live preview)
    document.addEventListener("keydown", (e) => {
      // don't steal keys from inputs
      const ae = document.activeElement;
      if (ae && (ae.tagName === "INPUT" || ae.isContentEditable)) return;

      if (mySlot == null) return;
      const tiles = currentRowTiles();
      if (!tiles.length) return;
      const myTile = tiles[mySlot];

      if (myTile.classList.contains("locked") &&
          e.key !== "Enter" && e.key !== "Backspace") return;

      if (/^[a-zA-Z]$/.test(e.key)) {
        e.preventDefault();
        if (myTile.classList.contains("locked")) return;
        const L = e.key.toUpperCase();
        myTile.textContent = L;
        ws?.send(JSON.stringify({ type: "previewLetter", letter: L }));
        applyCustomBorders(); renderAssist();
      } else if (e.key === "Backspace") {
        e.preventDefault();
        if (myTile.classList.contains("locked")) return;
        myTile.textContent = "";
        ws?.send(JSON.stringify({ type: "previewLetter", letter: "" }));
        applyCustomBorders(); renderAssist();
      } else if (e.key === "Enter") {
        e.preventDefault();
        const letter = (myTile.textContent || "").trim().toUpperCase();
        if (!/^[A-Z]$/.test(letter)) { showToast("Type one letter A‚ÄìZ in your tile."); return; }
        myTile.classList.add("locked"); // green via CSS
        ws?.send(JSON.stringify({ type: "submitLetter", letter }));
        applyCustomBorders(); renderAssist();
      }
    });

    // UI: name + color dropdown
    function initIdentityUI() {
      if (nameInput) nameInput.value = displayName;
      saveNameBtn.onclick = () => {
        const newName = (nameInput.value || "").trim().slice(0,16) || "Player";
        displayName = newName;
        localStorage.setItem("name", newName);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "setName", name: newName }));
          showToast("Name updated");
        } else {
          showToast("Name saved; connecting‚Ä¶");
        }
      };
      buildColorDropdown();
    }

    // WebSocket
    function connectWS() {
      const nameParam = encodeURIComponent(localStorage.getItem("name") || "Player");
      const wsUrl = `${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/ws?lobby=${params.get("lobby")}&name=${nameParam}`;
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        setStatus("connected");
        if (myColor) ws.send(JSON.stringify({ type: "setColor", color: myColor }));
      };
      ws.onclose = () => setStatus("disconnected");
      ws.onerror = () => setStatus("connection error");

      ws.onmessage = (ev) => {
        const msg = JSON.parse(ev.data);
        switch (msg.type) {
          case "error":
            showToast(msg.message);
            break;

          case "join":
            mySlot = msg.slot;
            round = msg.round;
            maxRounds = msg.maxRounds; // 5 from server
            buildGrid();
            renderHistory(msg.history);
            renderSlots(msg.slots);
            setShareLink();
            initIdentityUI();
            focusMyTile();
            renderAssist();
            break;

          case "roster":
            renderRoster(msg.players);
            // update color/occupancy maps
            for (const p of msg.players) {
              rosterColors[p.slot] = p.color || null;
              rosterOccupied[p.slot] = !!p.occupied;
            }
            applyCustomBorders();
            renderAssist();
            break;

          case "slotUpdate":
            applySlot(msg.slot, msg.slotState);
            applyCustomBorders();
            renderAssist();
            break;

          case "reveal":
            renderReveal(msg.round, msg.guess, msg.colors);
            if (msg.invalid) showToast(`‚Äú${msg.guess}‚Äù is not in the word list (counted).`);
            break;

          case "newRow":
            round = msg.round;
            applyCustomBorders();
            focusMyTile();
            renderAssist();
            break;

          case "rowUnlocked": // rare safeguard path
            renderSlots(msg.slots);
            applyCustomBorders();
            focusMyTile();
            renderAssist();
            break;

          case "waiting":
            if (msg.waitingFor?.length) {
              const human = msg.waitingFor.map(i => i + 1).join(", ");
              showToast(`Waiting for slots: ${human}`);
            }
            break;

          case "gameOver":
            endGame(msg);
            break;

          case "reset":
            resetClient(msg);
            break;
        }
      };
    }

    // Rendering
    function renderRoster(players) {
      rosterEl.innerHTML = "";
      for (const p of players) {
        const d = document.createElement("div");
        d.className = "slotBadge" + (p.occupied ? " occupied" : "");
        const dot = document.createElement("span");
        dot.className = "dot";
        if (p.color) dot.style.background = p.color;
        d.appendChild(dot);
        const label = document.createElement("span");
        label.textContent = p.occupied ? `Slot ${p.slot+1} ‚Äî ${p.name || "Player"}`
                                       : `Slot ${p.slot+1} ‚Äî (open)`;
        d.appendChild(label);
        rosterEl.appendChild(d);
      }
    }

    function renderHistory(history) {
      for (let r = 0; r < history.length; r++) {
        const h = history[r];
        const tiles = rows[r].tiles;
        for (let c = 0; c < 5; c++) {
          const t = tiles[c];
          t.textContent = h.guess[c];
          t.classList.remove("locked");
          t.classList.add(classFor(h.colors[c]));
          t.style.borderColor = ""; // let reveal border win
        }
      }
    }

    function renderSlots(slots) {
      const tiles = currentRowTiles();
      for (let i = 0; i < 5; i++) {
        const s = slots[i];
        const t = tiles[i];
        if (!t) continue;
        t.textContent = s.letter || "";
        t.classList.toggle("locked", !!s.locked);
        if (!s.locked) t.classList.remove("correct","present","absent"); // ensure editing look
        t.style.borderColor = ""; // will reapply via applyCustomBorders()
      }
    }

    function applySlot(slot, state) {
      const t = currentRowTiles()[slot];
      if (!t) return;
      t.textContent = state.letter || "";
      t.classList.toggle("locked", !!state.locked);
      if (!state.locked) t.classList.remove("correct","present","absent");
      t.style.borderColor = ""; // reapply via applyCustomBorders
    }

    function renderReveal(rowIndex, guess, colors) {
      const tiles = rows[rowIndex]?.tiles || [];
      for (let i = 0; i < 5; i++) {
        const t = tiles[i];
        if (!t) continue;
        t.classList.remove("locked","correct","present","absent");
        t.textContent = guess[i];
        t.classList.add(classFor(colors[i]));
        t.style.borderColor = ""; // reveal style controls border
        t.style.transform = "scale(1.06)";
        setTimeout(((tt)=>()=>tt.style.transform="scale(1)")(t), 140);
      }
    }

    function classFor(color) {
      if (color === "correct") return "correct";
      if (color === "present") return "present";
      return "absent";
    }

    function endGame({ reason, answer }) {
      blurMyTile();
      gameOverEl.hidden = false;
      gameOverEl.textContent =
        reason === "solved"
          ? `üéâ You cracked it! The word was ${answer}. Click to start a new game.`
          : `üß© Out of guesses. The word was ${answer}. Click to start a new game.`;
      gameOverEl.onclick = () => {
        ws?.send(JSON.stringify({ type: "requestReset" }));
        gameOverEl.hidden = true;
      };
      // Disable assist buttons on game over
      assistEl.querySelectorAll(".fillBtn").forEach(b => b.disabled = true);
    }

    function resetClient({ round: r, slots }) {
      round = r;
      buildGrid();
      renderSlots(slots);
      applyCustomBorders();
      focusMyTile();
      renderAssist();
      showToast("New game started!");
    }

    // Boot
    (async () => {
      await ensureLobby();
      setShareLink();
      buildGrid();
      connectWS();
      // init UI defaults
      if (nameInput) nameInput.value = displayName;
      buildColorDropdown();
    })();
  </script>
</body>
</html>
