<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Congeal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f1115;
      --panel: #161a21;
      --accent: #6ee7b7;
      --muted: #a0a8b8;
      --text: #e7e9ee;

      /* Wordle-style coloring per your spec */
      --correct: #22c55e;   /* green */
      --present: #eab308;   /* yellow */
      --absent: #ffffff;    /* white (absent) */

      --locked-border: #22c55e;
      --tile-bg: #0e1320;
      --tile-border: #273043;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: radial-gradient(1200px 600px at 70% -10%, #1b2230, var(--bg));
      color: var(--text); display: grid; place-items: center; padding: 20px;
    }

    .wrap { width: 100%; max-width: 920px; }
    header {
      display: flex; align-items: center; justify-content: space-between;
      margin-bottom: 16px; gap: 10px;
    }
    h1 { font-size: 22px; margin: 0; letter-spacing: 0.5px; }
    .meta { color: var(--muted); font-size: 14px; }

    .panel {
      background: linear-gradient(180deg, #171b23, #12161d);
      border: 1px solid #222938; border-radius: 14px; padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      width: 100%;
    }

    .topbar { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
    .linkbar { display: flex; gap: 8px; align-items: center; flex: 1; min-width: 340px; }
    .linkbar input {
      flex: 1; min-width: 260px; padding: 10px 12px; border-radius: 10px; border: 1px solid #273043;
      background: #0e1320; color: #cfe3ff; font-size: 14px;
    }
    button {
      background: var(--accent); color: #0a0f0d; font-weight: 700; border: 0;
      padding: 10px 14px; border-radius: 12px; cursor: pointer;
    }

    .namebar { display: flex; gap: 8px; align-items: center; margin: 6px 0 12px; flex-wrap: wrap; }
    .namebar input {
      min-width: 160px; padding: 8px 10px; border-radius: 10px; border: 1px solid #273043;
      background: #0e1320; color: #cfe3ff; font-size: 14px;
    }

    .colorbar { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-bottom: 12px; }
    .colorbar label { color: var(--muted); font-size: 14px; }
    .colorSelect {
      padding: 8px 10px; border-radius: 10px; border: 1px solid #273043;
      background: #0e1320; color: #cfe3ff; font-size: 14px; min-width: 180px;
    }
    .dot {
      width: 14px; height: 14px; border-radius: 50%; border: 1px solid #1f2937;
      display: inline-block; vertical-align: middle; margin-left: 6px;
    }

    /* grid */
    #grid { display: grid; gap: 10px; justify-content: center; }
    .row { display: grid; grid-template-columns: repeat(5, 64px); gap: 10px; }
    .tile {
      width: 64px; height: 64px; border-radius: 10px;
      border: 2px solid var(--tile-border); background: var(--tile-bg);
      display: grid; place-items: center; font-weight: 800; font-size: 28px;
      text-transform: uppercase; letter-spacing: 1px; user-select: none;
      outline: none; color: var(--text);
      transition: transform .08s ease, border-color .15s ease, background .15s ease;
    }
    .tile.focus { box-shadow: 0 0 0 3px rgba(110,231,183,.35); }
    .tile.locked { border-color: var(--locked-border) !important; } /* keep green when submitted */

    /* reveal colors */
    .tile.correct { background: var(--correct); border-color: #16a34a !important; color: #081207; }
    .tile.present { background: var(--present); border-color: #9e7d05 !important; color: #0a0900; }
    .tile.absent  { background: var(--absent);  border-color: #cbd5e1 !important; color: #0b0f17; }

    .roster { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; margin-top: 8px; }
    .slotBadge {
      padding: 6px 8px; border-radius: 10px; background: #0e1420; border: 1px solid #222938;
      text-align: center; font-size: 12px; color: var(--muted); display: flex; justify-content: center; align-items: center; gap: 6px;
    }

    .toast { margin-top: 10px; color: #ffd19a; min-height: 20px; }
    .gameOver {
      text-align: center; padding: 12px; border-radius: 12px;
      background: #161d29; border: 1px solid #273043; margin-top: 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Congeal</h1>
      <div class="meta" id="status">connectingâ€¦</div>
    </header>

    <div class="panel">
      <div class="topbar">
        <div class="linkbar">
          <input id="share" readonly />
          <button id="copy">Copy Link</button>
        </div>
        <button id="newRoom">Refresh Room Code</button>
      </div>

      <div class="namebar">
        <input id="nameInput" maxlength="16" placeholder="Your name" />
        <button id="saveName">Save</button>
      </div>

      <div class="colorbar">
        <label for="colorSelect">Border color:</label>
        <select id="colorSelect" class="colorSelect"></select>
        <span id="colorPreview" class="dot"></span>
      </div>

      <div id="grid"></div>
      <div class="roster" id="roster"></div>
      <div class="toast" id="toast"></div>
      <div class="gameOver" id="gameOver" hidden></div>
    </div>
  </div>

  <script>
    // Elements
    const qs = (s) => document.querySelector(s);
    const gridEl = qs("#grid");
    const rosterEl = qs("#roster");
    const shareEl = qs("#share");
    const copyBtn = qs("#copy");
    const newRoomBtn = qs("#newRoom");
    const statusEl = qs("#status");
    const toastEl = qs("#toast");
    const gameOverEl = qs("#gameOver");
    const nameInput = qs("#nameInput");
    const saveNameBtn = qs("#saveName");
    const colorSelect = qs("#colorSelect");
    const colorPreview = qs("#colorPreview");

    const params = new URLSearchParams(location.search);

    // Ensure we have a lobby code; else create one.
    async function ensureLobby() {
      if (!params.get("lobby")) {
        const res = await fetch("/create");
        const data = await res.json();
        const url = new URL(location.href);
        url.searchParams.set("lobby", data.lobbyId);
        history.replaceState({}, "", url.toString());
      }
    }

    // State
    let ws, mySlot = null;
    let round = 0, maxRounds = 5; // default 5; server will confirm
    const rows = []; // [{ el, tiles[5] }]
    const rosterColors = Array(5).fill(null);

    // Name bootstrap: ?name= first, then stored, else "Player"
    let displayName =
      (params.get("name") || localStorage.getItem("name") || "Player").trim().slice(0,16);
    localStorage.setItem("name", displayName);

    // Color palette (must match server)
    const PALETTE = ["#60A5FA","#F472B6","#F59E0B","#A78BFA","#14B8A6","#EF4444","#22D3EE","#FB7185","#8B5CF6","#F97316"];
    let myColor = localStorage.getItem("borderColor") || PALETTE[0];

    // Helpers
    function setStatus(msg) { statusEl.textContent = msg; }
    function showToast(msg) {
      toastEl.textContent = msg || "";
      if (!msg) return;
      setTimeout(() => { if (toastEl.textContent === msg) toastEl.textContent = ""; }, 2500);
    }
    function setShareLink() {
      shareEl.value = location.href;
      copyBtn.onclick = async () => {
        await navigator.clipboard.writeText(shareEl.value);
        showToast("Link copied.");
      };
      newRoomBtn.onclick = async () => {
        const res = await fetch("/create");
        const data = await res.json();
        location.href = data.joinUrl;
      };
    }

    function labelForColor(hex) {
      const map = {
        "#60A5FA": "Blue",
        "#F472B6": "Pink",
        "#F59E0B": "Amber",
        "#A78BFA": "Violet",
        "#14B8A6": "Teal",
        "#EF4444": "Red",
        "#22D3EE": "Cyan",
        "#FB7185": "Rose",
        "#8B5CF6": "Indigo",
        "#F97316": "Orange"
      };
      return map[hex] || hex;
    }

    function buildColorDropdown() {
      // Clear options
      colorSelect.innerHTML = "";
      for (const col of PALETTE) {
        const opt = document.createElement("option");
        opt.value = col;
        opt.textContent = labelForColor(col);
        opt.style.background = col; // some browsers show it
        opt.style.color = "#0b0f17";
        colorSelect.appendChild(opt);
      }
      // Set current value
      if (!PALETTE.includes(myColor)) myColor = PALETTE[0];
      colorSelect.value = myColor;
      colorPreview.style.background = myColor;

      colorSelect.onchange = () => {
        myColor = colorSelect.value;
        localStorage.setItem("borderColor", myColor);
        colorPreview.style.background = myColor;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "setColor", color: myColor }));
        }
        applyCustomBorders();
      };
    }

    // Grid
    function buildGrid() {
      gridEl.innerHTML = "";
      gridEl.style.gridTemplateRows = `repeat(${maxRounds}, 64px)`;
      rows.length = 0;
      for (let r = 0; r < maxRounds; r++) {
        const row = document.createElement("div");
        row.className = "row";
        const tiles = [];
        for (let c = 0; c < 5; c++) {
          const t = document.createElement("div");
          t.className = "tile";
          t.tabIndex = -1;
          t.textContent = "";
          row.appendChild(t);
          tiles.push(t);
        }
        gridEl.appendChild(row);
        rows.push({ el: row, tiles });
      }
    }
    function currentRowTiles() { return rows[round]?.tiles || []; }

    function focusMyTile() {
      if (mySlot == null) return;
      const tile = currentRowTiles()[mySlot];
      if (tile) { tile.classList.add("focus"); tile.focus({ preventScroll: true }); }
    }
    function blurMyTile() {
      const tile = currentRowTiles()[mySlot];
      if (tile) tile.classList.remove("focus");
    }

    // Apply per-slot custom borders to the current row (only when not locked/revealed)
    function applyCustomBorders() {
      const tiles = currentRowTiles();
      for (let i = 0; i < 5; i++) {
        const t = tiles[i];
        if (!t) continue;
        const isLocked = t.classList.contains("locked");
        const isRevealed = t.classList.contains("correct") || t.classList.contains("present") || t.classList.contains("absent");
        if (!isLocked && !isRevealed) {
          const col = rosterColors[i] || "#273043";
          t.style.borderColor = col;
        } else {
          t.style.borderColor = ""; // let locked/reveal CSS win
        }
      }
    }

    // Typing directly into your tile (with live preview)
    document.addEventListener("keydown", (e) => {
      // don't steal keys from inputs
      const ae = document.activeElement;
      if (ae && (ae.tagName === "INPUT" || ae.isContentEditable)) return;

      if (mySlot == null) return;
      const tiles = currentRowTiles();
      if (!tiles.length) return;
      const myTile = tiles[mySlot];

      if (myTile.classList.contains("locked") &&
          e.key !== "Enter" && e.key !== "Backspace") return;

      if (/^[a-zA-Z]$/.test(e.key)) {
        e.preventDefault();
        if (myTile.classList.contains("locked")) return;
        const L = e.key.toUpperCase();
        myTile.textContent = L;
        ws?.send(JSON.stringify({ type: "previewLetter", letter: L }));
        applyCustomBorders();
      } else if (e.key === "Backspace") {
        e.preventDefault();
        if (myTile.classList.contains("locked")) return;
        myTile.textContent = "";
        ws?.send(JSON.stringify({ type: "previewLetter", letter: "" }));
        applyCustomBorders();
      } else if (e.key === "Enter") {
        e.preventDefault();
        const letter = (myTile.textContent || "").trim().toUpperCase();
        if (!/^[A-Z]$/.test(letter)) { showToast("Type one letter Aâ€“Z in your tile."); return; }
        myTile.classList.add("locked"); // green via CSS
        ws?.send(JSON.stringify({ type: "submitLetter", letter }));
        applyCustomBorders();
      }
    });

    // UI: name + color dropdown
    function initIdentityUI() {
      if (nameInput) nameInput.value = displayName;
      saveNameBtn.onclick = () => {
        const newName = (nameInput.value || "").trim().slice(0,16) || "Player";
        displayName = newName;
        localStorage.setItem("name", newName);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "setName", name: newName }));
          showToast("Name updated");
        } else {
          showToast("Name saved; connectingâ€¦");
        }
      };
      buildColorDropdown();
    }

    // WebSocket
    function connectWS() {
      const nameParam = encodeURIComponent(localStorage.getItem("name") || "Player");
      const wsUrl = `${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/ws?lobby=${params.get("lobby")}&name=${nameParam}`;
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        setStatus("connected");
        // send preferred color after connect
        if (myColor) ws.send(JSON.stringify({ type: "setColor", color: myColor }));
      };
      ws.onclose = () => setStatus("disconnected");
      ws.onerror = () => setStatus("connection error");

      ws.onmessage = (ev) => {
        const msg = JSON.parse(ev.data);
        switch (msg.type) {
          case "error":
            showToast(msg.message);
            break;

          case "join":
            mySlot = msg.slot;
            round = msg.round;
            maxRounds = msg.maxRounds; // should be 5 from server
            buildGrid();
            renderHistory(msg.history);
            renderSlots(msg.slots);
            setShareLink();
            initIdentityUI();
            focusMyTile();
            break;

          case "roster":
            renderRoster(msg.players);
            // update color map
            for (const p of msg.players) {
              rosterColors[p.slot] = p.color || null;
            }
            applyCustomBorders();
            break;

          case "slotUpdate":
            applySlot(msg.slot, msg.slotState);
            applyCustomBorders();
            break;

          case "reveal":
            renderReveal(msg.round, msg.guess, msg.colors); // color the exact row
            if (msg.invalid) showToast(`â€œ${msg.guess}â€ is not in the word list (counted).`);
            break;

          case "newRow":
            round = msg.round;
            applyCustomBorders();
            focusMyTile();
            break;

          case "rowUnlocked": // rare safeguard path
            renderSlots(msg.slots);
            applyCustomBorders();
            focusMyTile();
            break;

          case "waiting":
            if (msg.waitingFor?.length) {
              const human = msg.waitingFor.map(i => i + 1).join(", ");
              showToast(`Waiting for slots: ${human}`);
            }
            break;

          case "gameOver":
            endGame(msg);
            break;

          case "reset":
            resetClient(msg);
            break;
        }
      };
    }

    // Rendering
    function renderRoster(players) {
      rosterEl.innerHTML = "";
      for (const p of players) {
        const d = document.createElement("div");
        d.className = "slotBadge" + (p.occupied ? " occupied" : "");
        const dot = document.createElement("span");
        dot.className = "dot";
        if (p.color) dot.style.background = p.color;
        d.appendChild(dot);
        const label = document.createElement("span");
        label.textContent = p.occupied ? `Slot ${p.slot+1} â€” ${p.name || "Player"}`
                                       : `Slot ${p.slot+1} â€” (open)`;
        d.appendChild(label);
        rosterEl.appendChild(d);
      }
    }

    function renderHistory(history) {
      for (let r = 0; r < history.length; r++) {
        const h = history[r];
        const tiles = rows[r].tiles;
        for (let c = 0; c < 5; c++) {
          const t = tiles[c];
          t.textContent = h.guess[c];
          t.classList.remove("locked");
          t.classList.add(classFor(h.colors[c]));
          t.style.borderColor = ""; // let reveal border win
        }
      }
    }

    function renderSlots(slots) {
      const tiles = currentRowTiles();
      for (let i = 0; i < 5; i++) {
        const s = slots[i];
        const t = tiles[i];
        if (!t) continue;
        t.textContent = s.letter || "";
        t.classList.toggle("locked", !!s.locked);
        if (!s.locked) t.classList.remove("correct","present","absent"); // ensure editing look
        t.style.borderColor = ""; // will reapply via applyCustomBorders()
      }
    }

    function applySlot(slot, state) {
      const t = currentRowTiles()[slot];
      if (!t) return;
      t.textContent = state.letter || "";
      t.classList.toggle("locked", !!state.locked);
      if (!state.locked) t.classList.remove("correct","present","absent");
      t.style.borderColor = ""; // reapply via applyCustomBorders
    }

    function renderReveal(rowIndex, guess, colors) {
      const tiles = rows[rowIndex]?.tiles || [];
      for (let i = 0; i < 5; i++) {
        const t = tiles[i];
        if (!t) continue;
        t.classList.remove("locked","correct","present","absent");
        t.textContent = guess[i];
        t.classList.add(classFor(colors[i]));
        t.style.borderColor = ""; // reveal style controls border
        t.style.transform = "scale(1.06)";
        setTimeout(((tt)=>()=>tt.style.transform="scale(1)")(t), 140);
      }
    }

    function classFor(color) {
      if (color === "correct") return "correct";
      if (color === "present") return "present";
      return "absent";
    }

    function endGame({ reason, answer }) {
      blurMyTile();
      gameOverEl.hidden = false;
      gameOverEl.textContent =
        reason === "solved"
          ? `ðŸŽ‰ You cracked it! The word was ${answer}. Click to start a new game.`
          : `ðŸ§© Out of guesses. The word was ${answer}. Click to start a new game.`;
      gameOverEl.onclick = () => {
        ws?.send(JSON.stringify({ type: "requestReset" }));
        gameOverEl.hidden = true;
      };
    }

    function resetClient({ round: r, slots }) {
      round = r;
      buildGrid();
      renderSlots(slots);
      applyCustomBorders();
      focusMyTile();
      showToast("New game started!");
    }

    // Boot
    (async () => {
      await ensureLobby();
      setShareLink();
      buildGrid();
      connectWS();
      // init UI defaults
      if (nameInput) nameInput.value = displayName;
      buildColorDropdown();
    })();
  </script>
</body>
</html>
